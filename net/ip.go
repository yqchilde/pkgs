package net

import (
	"bytes"
	"errors"
	"fmt"
	"log"
	"net"
	"net/http"
	"os/exec"
	"runtime"
	"strconv"
	"strings"
)

var clientIP = "192.168.0.1"

// GetIPNet 获取IPNet对象
func GetIPNet() (*net.IPNet, error) {
	iFaces, err := net.Interfaces()
	if err != nil {
		return nil, err
	}

	for _, iFace := range iFaces {
		addrs, err := iFace.Addrs()
		if err != nil {
			return nil, err
		}

		for _, addr := range addrs {
			if ip, ok := addr.(*net.IPNet); ok && !ip.IP.IsLoopback() {
				if ip.IP.To4() != nil {
					return ip, nil
				}
			}
		}
	}
	return nil, errors.New("failed get ip net")
}

// GetIPWithLocal 获取本地内网IP
func GetIPWithLocal() (string, error) {
	ipNet, err := GetIPNet()
	if err != nil {
		return clientIP, err
	}

	return ipNet.IP.String(), nil
}

// CheckIpNet 判断ip是否为内网地址
func CheckIpNet(ip string) (bool, error) {
	if ip == "localhost" {
		return true, nil
	}
	var isIntranet bool
	if len(strings.Split(ip, "http://")) >= 2 {
		ip = strings.Split(ip, "http://")[1]
	}
	ipList := strings.Split(ip, ".")
	if len(ipList) < 4 {
		return false, errors.New("ip错误")
	}

	if ipList[0] == "10" || ipList[0] == "172" || ipList[0] == "192" || ipList[0] == "127" {
		if ipList[0] == "172" {
			tmp, err := strconv.Atoi(ipList[1])
			if err != nil {
				return false, err
			}
			if tmp >= 16 && tmp <= 31 {
				isIntranet = true
			}
		} else {
			isIntranet = true
		}
	}
	return isIntranet, nil
}

// GetIPSubnetMask 获取ip子网掩码
func GetIPSubnetMask() (string, error) {
	var subnetMask string
	ipNet, err := GetIPNet()
	if err != nil {
		return subnetMask, err
	}

	mask := fmt.Sprintf("%d", ipNet.Mask)
	subnetMask = strings.ReplaceAll(mask[1:len(mask)-1], " ", ".")
	return subnetMask, nil
}

// GeIPtDnsServer 获取DnsServer
func GeIPtDnsServer() (string, error) {
	var dnsServer string

	// # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
	// #     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
	// # 127.0.0.53 is the systemd-resolved stub resolver.
	// # run "systemd-resolve --status" to see details about the actual nameservers.
	//
	// 	nameserver 127.0.0.53
	cmd := exec.Command("cat", "/etc/resolv.conf")
	var out bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &stderr
	err := cmd.Run()
	if err != nil {
		return stderr.String(), err
	} else {
		fields := strings.Fields(out.String())
		for i := range fields {
			if fields[i] == "nameserver" {
				dnsServer = fields[i+1]
				break
			}
		}
		return dnsServer, nil
	}
}

// GetIPGateway 获取IP默认网关
func GetIPGateway() (string, error) {
	var gateway string
	system := runtime.GOOS
	switch system {
	case "linux":
		// Kernel IP routing table
		// Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
		// 0.0.0.0         10.20.10.1      0.0.0.0         UG    100    0        0 eth0
		// 10.20.10.0      0.0.0.0         255.255.254.0   U     100    0        0 eth0
		// 169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 docker0
		// 172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
		cmd := exec.Command("route", "-n")
		var out bytes.Buffer
		var stderr bytes.Buffer
		cmd.Stdout = &out
		cmd.Stderr = &stderr
		err := cmd.Run()
		if err != nil {
			return stderr.String(), err
		} else {
			fields := strings.Fields(out.String())
			for i := range fields {
				if fields[i] == "UG" {
					gateway = fields[i-2]
					break
				}
			}
			return gateway, nil
		}
	case "darwin":
		// route to: default
		// destination: default
		// mask: default
		// gateway: 10.20.10.1
		// interface: en0
		// flags: <UP,GATEWAY,DONE,STATIC,PRCLONING,GLOBAL>
		// recvpipe  sendpipe  ssthresh  rtt,msec    rttvar  hopcount      mtu     expire
		// 0         0         0         0         0         0      1500         0
		cmd := exec.Command("route", "-n", "get", "default")
		var out bytes.Buffer
		var stderr bytes.Buffer
		cmd.Stdout = &out
		cmd.Stderr = &stderr
		err := cmd.Run()
		if err != nil {
			return stderr.String(), err
		} else {
			fields := strings.Fields(out.String())
			for i := range fields {
				if fields[i] == "gateway:" {
					gateway = fields[i+1]
					break
				}
			}
			return gateway, nil
		}
	}
	return gateway, errors.New("failed get ip default gateway")
}

// IpMaskToInt ip掩码转int
func IpMaskToInt(netmask string) (int, error) {
	ipSplitArr := strings.Split(netmask, ".")
	if len(ipSplitArr) != 4 {
		return 0, fmt.Errorf("子网掩码:%v 是无效的, 格式应该像这样: 255.255.255.0", netmask)
	}
	ipv4MaskArr := make([]byte, 4)
	for i, value := range ipSplitArr {
		intValue, err := strconv.Atoi(value)
		if err != nil {
			log.Printf("ipMaskToInt call strconv.Atoi error:[%v] string value is: [%s]", err, value)
			return 0, errors.New("IP子网掩码设置失败")
		}
		if intValue > 255 {
			log.Printf("netmask cannot greater than 255, current value is: [%s]", value)
			return 0, errors.New("IP子网掩码设置失败")
		}
		ipv4MaskArr[i] = byte(intValue)
	}

	ones, _ := net.IPv4Mask(ipv4MaskArr[0], ipv4MaskArr[1], ipv4MaskArr[2], ipv4MaskArr[3]).Size()
	return ones, nil
}

// IpMaskToIntMust ip掩码转int，不返回error
func IpMaskToIntMust(netmask string) int {
	ipSplitArr := strings.Split(netmask, ".")
	if len(ipSplitArr) != 4 {
		return 0
	}
	ipv4MaskArr := make([]byte, 4)
	for i, value := range ipSplitArr {
		intValue, err := strconv.Atoi(value)
		if err != nil {
			log.Printf("ipMaskToInt call strconv.Atoi error:[%v] string value is: [%s]", err, value)
			return 0
		}
		if intValue > 255 {
			log.Printf("netmask cannot greater than 255, current value is: [%s]", value)
			return 0
		}
		ipv4MaskArr[i] = byte(intValue)
	}

	ones, _ := net.IPv4Mask(ipv4MaskArr[0], ipv4MaskArr[1], ipv4MaskArr[2], ipv4MaskArr[3]).Size()
	return ones
}

func GetEthernetInfo() ([]net.Interface, error) {
	netInterfaces, err := net.Interfaces()
	if err != nil {
		return nil, errors.New("获取网卡信息失败")
	}

	var ethCard []net.Interface
	for _, netInterface := range netInterfaces {
		// 判断是否是Ethernet协议
		if strings.HasPrefix(netInterface.Name, "eth") {
			ethCard = append(ethCard, netInterface)
		}
	}
	if len(ethCard) == 0 {
		return ethCard, errors.New("未找到网卡信息")
	}

	return ethCard, nil
}

// GetEtherNetMacAddr 获取指定网卡MAC地址，Ps: netCard: eth0
func GetEtherNetMacAddr(netCard string) (macAddr string, err error) {
	netInterfaces, err := net.Interfaces()
	if err != nil {
		return macAddr, err
	}

	for _, netInterface := range netInterfaces {
		if netInterface.Name == netCard {
			macAddr = netInterface.HardwareAddr.String()
			break
		}
	}
	if macAddr == "" {
		return macAddr, errors.New("failed to get mac address")
	}

	return macAddr, nil
}

// GetRealIP get user real ip
func GetRealIP(req *http.Request) (ip string) {
	var header = req.Header
	var index int
	if ip = header.Get("X-Forwarded-For"); ip != "" {
		index = strings.IndexByte(ip, ',')
		if index < 0 {
			return ip
		}
		if ip = ip[:index]; ip != "" {
			return ip
		}
	}
	if ip = header.Get("X-Real-Ip"); ip != "" {
		index = strings.IndexByte(ip, ',')
		if index < 0 {
			return ip
		}
		if ip = ip[:index]; ip != "" {
			return ip
		}
	}
	if ip = header.Get("Proxy-Forwarded-For"); ip != "" {
		index = strings.IndexByte(ip, ',')
		if index < 0 {
			return ip
		}
		if ip = ip[:index]; ip != "" {
			return ip
		}
	}
	ip, _, _ = net.SplitHostPort(req.RemoteAddr)
	return ip
}
